---
title: 연결 속성 설정
description: Microsoft JDBC Driver for SQL Server에 대한 연결 문자열 속성은 다양한 방식으로 지정할 수 있습니다.
ms.custom: ''
ms.date: 12/04/2020
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
ms.assetid: f1b62700-f046-488d-bd6b-a5cd8fc345b7
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 29d8ab48623b2eeb2d4cd3a367499bdbe67375f7
ms.sourcegitcommit: cad737d30e5a80033f3b021cc3f0d47c00756a6b
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 12/04/2020
ms.locfileid: "96614475"
---
# <a name="setting-the-connection-properties"></a>연결 속성 설정

[!INCLUDE[Driver_JDBC_Download](../../includes/driver_jdbc_download.md)]

연결 문자열 속성을 지정하는 방식에는 여러 가지가 있습니다.

- DriverManager 클래스를 사용하여 연결할 때 연결 URL에 이름=값 속성으로 지정합니다.
- DriverManager 클래스에서 Connect 메서드의 *속성* 매개 변수에 이름=값 속성으로 지정합니다.
- 드라이버 데이터 원본의 해당 setter 메서드에 값으로 지정 다음은 그 예입니다.  
  
    ```java
    datasource.setServerName(value)  
    datasource.setDatabaseName(value)  
    ```  
  
## <a name="remarks"></a>설명

속성 이름은 대/소문자를 구분하지 않으며 중복된 속성 이름을 다음 순서로 확인합니다.  
  
1. API 인수(예: 사용자 및 암호)
2. 속성 컬렉션.  
3. 연결 문자열의 마지막 인스턴스.
  
또한 속성 이름에 알 수 없는 값이 허용될 뿐만 아니라 JDBC Driver에서는 이 값의 대/소문자에 대한 유효성을 검사하지 않습니다.

동의어를 허용하고 중복 속성 이름처럼 순서대로 확인합니다.

다음 표에서는 JDBC 드라이버에 현재 사용할 수 있는 모든 연결 문자열 속성을 나열합니다.

| 속성<br/>Type<br/>기본값 | Description |
| :------------------------------ | :---------- |
| accessToken<br/><br/>String<br/><br/>null | 액세스 토큰을 사용하여 SQL Database에 연결하려면 이 속성을 사용합니다. **accessToken** 은 연결 URL을 사용하여 설정할 수 없습니다. |
| applicationIntent<br/><br/>String<br/><br/>ReadWrite | 서버에 연결할 때 애플리케이션 작업 유형을 선언합니다. <br/><br/>가능한 값은 **ReadOnly** 및 **ReadWrite** 입니다. <br/><br/>자세한 내용은 [고가용성, 재해 복구를 위한 JDBC 드라이버 지원](jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요. |
| applicationName<br/><br/>String<br/>[&lt;=128 char]<br/><br/>null | 애플리케이션 이름 또는 이름을 지정하지 않은 경우 "[!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]"가 됩니다.<br/><br/>다양한 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 프로파일링 및 로깅 도구에서 특정 애플리케이션을 식별하는 데 사용합니다. |
| 인증<br/><br/>String<br/><br/>NotSpecified | Microsoft JDBC Driver 6.0 for SQL Server부터는 연결에 사용할 SQL 인증 방법이 이 옵션 속성으로 표시됩니다. 가능한 값은 **ActiveDirectoryIntegrated**, **ActiveDirectoryPassword**, **ActiveDirectoryMSI**, **SqlPassword**, 그리고 기본값인 **NotSpecified** 입니다.<br/><br/> **ActiveDirectoryIntegrated** 를 사용하면 통합된 Windows 인증으로 SQL Database에 연결합니다.<br/><br/> **ActiveDirectoryPassword** 를 사용하면 Azure AD 사용자 이름과 암호로 SQL Database에 연결합니다.<br/><br/> **ActiveDirectoryMSI** 를 사용하여 Azure 리소스 내에서 SQL Database에 연결합니다. 예를 들어 Azure 가상 머신, App Service 또는 함수 앱이 MSI(관리 ID) 인증을 사용합니다. <br><br>**ActiveDirectoryMSI** 인증 모드 사용 시 드라이버가 지원하는 관리 ID는 다음 두 가지 유형으로 나뉩니다. <br> 1. _시스템 할당 관리 ID_: 기본적으로 **accessToken** 을 가져오는 데 사용됩니다. <br> 2. _사용자 할당 관리 ID_: MSI(관리 ID)의 클라이언트 ID가 **msiClientId** 연결 속성으로 지정된 경우 **accessToken** 을 가져오는 데 사용됩니다.<br/><br/> **SqlPassword** 를 사용하여 **사용자 이름**/**사용자** 및 **암호** 속성을 사용하여 SQL Server에 연결합니다.<br/><br/> 이러한 인증 방법이 모두 불필요한 경우에는 **NotSpecified** 를 사용합니다.<br/><br/> **중요:**  인증이 ActiveDirectoryIntegrated로 설정된 경우 **mssql-jdbc_auth-\<version>-\<arch>.dll**(JDBC 드라이버 패키지에서 사용 가능) 및 SQL Server용 Azure Active Directory 인증 라이브러리(**ADAL.DLL**)라는 두 라이브러리를 설치해야 합니다. ADAL은 [Microsoft ODBC Driver for SQL Server](../odbc/download-odbc-driver-for-sql-server.md) 또는 [Microsoft OLE DB Driver for SQL Server](../oledb/download-oledb-driver-for-sql-server.md)를 설치할 때 함께 설치됩니다. JDBC 드라이버는 ADAL.DLL에 대해 버전 **1.0.2028.318 이상** 만 지원합니다.<br/><br/> **참고:**  인증 속성이 **NotSpecified** 이외의 값으로 설정되어 있으면, 드라이버는 기본적으로 이전에 SSL(Secure Sockets Layer)로 알려진 TLS(전송 계층 보안) 암호화를 사용합니다.<br/><br/> Azure Active Directory 인증을 구성하는 방법에 대한 자세한 내용은 [Azure Active Directory 인증을 사용하여 SQL Database에 연결](/azure/azure-sql/database/authentication-aad-overview)을 참조하세요. |
| authenticationScheme<br/><br/>String<br/><br/>NativeAuthentication | 애플리케이션에서 사용하려는 통합 보안의 종류를 나타냅니다. 가능한 값은 **JavaKerberos**, **NTLM**, 그리고 기본값인 **NativeAuthentication** 입니다.<br/><br/> **NativeAuthentication** 을 사용하면 드라이버가 통합 인증 정보를 얻는 데 사용되는 Windows의 `mssql-jdbc_auth-<version>-<arch>.dll`(예: `mssql-jdbc_auth-8.2.2.x64.dll`)을 로드합니다. <br/><br/>  (로드된 네이티브 인증 라이브러리는 드라이버 버전 6.0~7.4를 사용할 때 `sqljdbc_auth.dll`로 이름이 지정됩니다.) <br/><br/> **authenticationScheme=JavaKerberos** 를 사용할 때는 **serverName** 또는 **serverSpn** 속성 내의 FQDN(정규화된 도메인 이름) 지정이 필요합니다. 그렇지 않으면 오류가 발생합니다(Kerberos 데이터베이스에서 서버를 찾을 수 없음).<br/><br/> **authenticationScheme=JavaKerberos** 사용에 대한 자세한 내용은 [Kerberos 통합 인증을 사용하여 SQL Server에 연결](using-kerberos-integrated-authentication-to-connect-to-sql-server.md)을 참조하세요. <br/><br/> **authenticationScheme=NTLM** 을 사용할 때는 **domain** 또는 **domainName** 속성 내에서 NTLM을 사용하여 인증하기 위한 Windows 도메인 지정과 함께 **user** 나 **userName**, 그리고 **password** 속성의 Windows 자격 증명이 필요합니다. 그렇지 않으면 오류가 발생합니다(연결 속성 지정이 필요함).  |
| cancelQueryTimeout<br/><br/>int<br/><br/>-1 | SQL Server용 Microsoft JDBC Driver 6.4부터는 이 속성을 사용하여 연결에 설정된 **queryTimeout** 을 취소할 수 있습니다. SQL Server에 대한 TCP 연결이 자동으로 삭제되는 경우에는 쿼리 실행이 중단되고 예외가 발생하지 않습니다. 이 속성은 연결에 'queryTimeout'도 설정된 경우에만 적용할 수 있습니다. <br/><br/>드라이버는 **cancelQueryTimeout** + **queryTimeout** 초를 모두 기다리고 연결을 삭제 후 채널을 닫습니다. <br/><br/>이 속성의 기본값은 -1이며, 무기한 대기하는 동작입니다. |
| clientCertificate<br/><br/>String<br/><br/>null | 클라이언트 인증서 인증에 사용할 인증서의 위치를 지정합니다. JDBC 드라이버는 PFX, PEM, DER 및 CER 파일 확장을 지원합니다. <br/><br/>자세한 내용은 [루프백 시나리오를 위한 클라이언트 인증서 인증](client-certification-authentication-for-loopback-scenarios.md)을 참조하세요. |
| clientKey <br/><br/>String<br/><br/>null | clientCertificate 특성에 지정된 PEM, DER 및 CER 인증서에 대해 프라이빗 키의 파일 위치를 지정합니다. <br/><br/>자세한 내용은 [루프백 시나리오를 위한 클라이언트 인증서 인증](client-certification-authentication-for-loopback-scenarios.md)을 참조하세요. |
| clientKeyPassword <br/><br/>String<br/><br/>null | clientKey 파일의 프라이빗 키에 액세스하기 위한 선택적 암호 문자열을 지정합니다. <br/><br/>자세한 내용은 [루프백 시나리오를 위한 클라이언트 인증서 인증](client-certification-authentication-for-loopback-scenarios.md)을 참조하세요. |
| columnEncryptionSetting<br/><br/>String<br/>["사용" &#124; "사용 안 함"]<br/><br/>사용 안 함 | SQL Server용 Microsoft JDBC Driver 6.0부터 AE(항상 암호화) 기능을 사용하려면 "사용함"으로 설정합니다. AE를 사용하도록 설정하면 JDBC 드라이버가 SQL Server의 암호화된 데이터베이스 열에 저장되어 있는 중요한 데이터를 투명하게 암호화하고 암호를 해독합니다.<br/><br/> **columnEncryptionSetting** 에 대한 자세한 내용은 [Always Encrypted와 JDBC 드라이버 사용](using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요.<br/><br/> **참고:**  Always Encrypted는 SQL Server 2016 이상 버전에서 사용할 수 있습니다. |
| databaseName,<br/>데이터베이스<br/><br/>String<br/>[&lt;=128 char]<br/><br/>null | 연결할 데이터베이스 이름입니다. <br/><br/>지정하지 않으면 기본 데이터베이스에 연결합니다. |
| delayLoadingLobs<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | ResultSet에서 검색되는 LOB 개체를 모두 스트림할지 여부를 나타내는 플래그입니다. 이 속성을 "false"로 설정하면 전체 LOB 개체가 스트리밍 없이 메모리에 로드됩니다. |
| domainName,<br/>도메인<br/><br/>String<br/>null | NTLM을 사용하여 인증할 Windows 도메인입니다. |
| disableStatementPooling<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | 문 풀링이 사용되어야 할지 여부를 나타내는 플래그입니다. |
| enablePrepareOnFirst...<br/>PreparedStatementCall<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _enablePrepareOnFirstPreparedStatementCall_<br/><br/> "true"로 설정하면 준비된 문의 첫 실행에 <code>sp_prepexec</code>를 호출하여 준비된 문 핸들의 생성을 사용 설정합니다. <br/><br/>“false”로 설정하면 준비된 문의 첫 실행을 변경하여 <code>sp_executesql</code>를 호출하고 문을 준비하지 않으며, 두 번째로 실행되면 <code>sp_prepexec</code>를 호출하여 준비된 문 핸들을 설정하게 됩니다. |
| enclaveAttestationUrl<br/><br/>String<br/><br/>null | SQL Server용 Microsoft JDBC Driver 8.2부터 이 선택적 속성은 보안 Enclave를 사용한 Always Encrypted에 사용할 증명 서비스 엔드포인트 URL을 나타냅니다.<br/><br/>자세한 내용은 [보안 Enclave를 사용한 Always Encrypted](../../connect/jdbc/using-always-encrypted-with-secure-enclaves-with-the-jdbc-driver.md)를 참조하세요. |
| enclaveAttestationProtocol<br/><br/>String<br/><br/>null | SQL Server용 Microsoft JDBC Driver 8.2부터 이 선택적 속성은 보안 Enclave를 사용한 Always Encrypted에 사용할 증명 프로토콜을 나타냅니다. 현재 이 필드에 지원되는 유일한 값은 **HGS** 입니다.<br/><br/>자세한 내용은 [보안 Enclave를 사용한 Always Encrypted](../../connect/jdbc/using-always-encrypted-with-secure-enclaves-with-the-jdbc-driver.md)를 참조하세요. |
| encrypt<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | 서버에 인증서가 설치된 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 클라이언트와 서버 간에 전송되는 모든 데이터에 TLS 암호화를 사용하도록 지정하려면 “true”로 설정합니다. 기본값은 "false"입니다.<br/><br/> Microsoft JDBC Driver 6.0 for SQL Server부터, 기본적으로 TLS 암호화를 사용하는 새 연결 설정인 ‘인증’이 있습니다. <br/><br/>자세한 내용은 '인증' 속성을 참조하세요. |
| failoverPartner<br/><br/>String<br/><br/>null | 데이터베이스 미러링 구성에서 사용되는 장애 조치 서버의 이름입니다. 이 속성은 주 서버에 대한 초기 연결 실패 시 사용되며 초기 연결이 이루어진 후에는 무시됩니다. databaseName 속성과 함께 사용해야 합니다.<br/><br/> **참고:** 연결 문자열에서 failoverPartner 속성의 일부로 장애 조치(failover) 파트너 인스턴스의 서버 인스턴스 포트 번호를 지정하는 작업은 드라이버에서 지원되지 않습니다. 그러나 주 서버 인스턴스의 serverName, instanceName 및 portNumber 속성과 장애 조치(failover) 파트너 인스턴스의 failoverPartner 속성을 동일한 연결 문자열에 지정할 수는 있습니다.<br/><br/> **Server** 연결 속성에 Virtual Network 이름을 지정하는 경우 데이터베이스 미러링을 사용할 수 없습니다. 자세한 내용은 [고가용성, 재해 복구를 위한 JDBC 드라이버 지원](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요. |
| fips<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>"false" | FIPS가 사용 설정된 JVM의 경우에는 이 속성이 **true** 여야 합니다. |
| fipsProvider<br/><br/>String<br/><br/>null | JVM에서 구성된 FIPS 공급자입니다. 그 예로는 BCFIPS 또는 SunPKCS11-NSS를 들 수 있습니다. 버전 6.4.0에서 제거되었습니다. 자세한 내용은 [여기](https://github.com/Microsoft/mssql-jdbc/pull/460)를 참조하세요. |
| gsscredential<br/><br/>org.ietf.jgss.GSSCredential<br/><br/>null | SQL Server용 Microsoft JDBC Driver 6.2부터는 Kerberos 제한된 위임에 사용되는 사용자 자격 증명이 이 속성으로 전달 가능합니다. <br/><br/>이는 **JavaKerberos** 를 **true** 로 **설정** 하 고 **authenticationscheme** 로 사용 해야 합니다. |
| hostNameInCertificate<br/><br/>String<br/><br/>null | [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] TLS/SSL 인증서의 유효성을 검사할 때 사용할 호스트 이름입니다.<br/><br/> hostNameInCertificate 속성이 지정되지 않았거나 null로 설정되어 있으면, [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]는 연결 URL의 **serverName** 속성 값을 호스트 이름으로 사용하여 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] TLS/SSL 인증서의 유효성을 검사합니다.<br/><br/> **참고:**  이 속성은 **encrypt**/**authentication** 속성 및 **trustServerCertificate** 속성과 함께 사용이 가능합니다. 이 속성은 TLS 암호화가 연결에 사용되고 **trustServerCertificate** 의 설정이 “false”인 경우에만 인증서 유효성 검사에 영향을 줍니다. TLS 연결이 성공하려면 **hostNameInCertificate** 에 전달된 값이 서버 인증서의 SAN(주체 대체 이름)에 있는 CN(일반 이름) 또는 DNS 이름과 정확히 일치해야 합니다. 자세한 내용은 [암호화 지원 이해](../../connect/jdbc/understanding-ssl-support.md)를 참조하세요. |
| INSTANCENAME<br/><br/>String<br/>[&lt;=128 char]<br/><br/>null | 연결할 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 인스턴스 이름입니다. 지정하지 않으면 기본 인스턴스에 연결합니다. instanceName 및 포트를 모두 지정하는 경우에 대해서는 포트 관련 설명을 참조하십시오.<br/><br/> **Server** 연결 속성에 Virtual Network 이름을 지정하는 경우 **instanceName** 연결 속성을 사용할 수 없습니다. 자세한 내용은 [고가용성, 재해 복구를 위한 ODBC 드라이버 지원](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요. |
| integratedSecurity<br/><br/>boolean<br/>["true"&#124;"false"]<br/><br/>false | "true"로 설정되면 Windows 운영 체제의 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 Windows 자격 증명을 사용한다는 뜻입니다. "true"일 경우 JDBC 드라이버는 사용자의 컴퓨터 또는 네트워크 로그인 시 제공된 자격 증명에 대해 로컬 컴퓨터 자격 증명 캐시를 검색합니다.<br/><br/> "true"(**authenticationscheme=JavaKerberos**)로 설정되면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 Kerberos 자격 증명을 사용함을 뜻합니다. Kerberos 인증에 대한 자세한 내용은 [Kerberos 통합 인증을 사용하여 SQL Server에 연결](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md)을 참조하세요. <br/><br/> "true"(**authenticationscheme=NTLM**)로 설정되면 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 NTLM 자격 증명을 사용함을 뜻합니다. <br/><br/> "false"로 설정하는 경우 사용자 이름과 암호를 입력해야 합니다. |
| jaasConfigurationName<br/><br/>String<br/><br/>SQLJDBCDriver | SQL Server용 Microsoft JDBC Driver 6.2부터는 SQL Server로의 연결마다 Kerberos 연결 설정을 위한 JAAS 로그인 구성 파일이 있습니다. 이 속성을 통해 로그인 구성 파일의 이름을 전달할 수 있습니다. <br/> 드라이버는 기본적으로 IBM JVM의 경우 `useDefaultCcache = true` 속성을, 기타 JVM의 경우 `useTicketCache = true` 속성을 설정합니다. |
| keyStoreAuthentication<br/><br/>String<br/><br/>null | SQL Server용 Microsoft JDBC Driver 6.0부터는 이 속성이 Always Encrypted와의 연결을 위해 어떤 키 저장소를 원활히 설정할지를 확인하고 해당 키 저장소의 인증에 사용될 인증 메커니즘을 결정합니다. SQL Server용 Microsoft JDBC Driver 6.0은 "**keyStoreAuthentication=JavaKeyStorePassword**" 설정에 필요한 이 속성으로 Java 키 저장소의 원활한 설정을 지원합니다. 이 속성을 사용하려면 Java 키 저장소에 대해 **keyStoreLocation** 및 **keyStoreSecret** 속성 설정도 필요합니다. <br/><br/>자세한 내용은 [JDBC 드라이버에서 Always Encrypted 사용](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요. <br/><br/> 또는 Microsoft JDBC Driver 8.4부터 관리 ID를 사용하여 Azure Key Vault에 인증하기 위해 "**keyStoreAuthentication=KeyVaultManagedIdentity**" 또는 "**keyStoreAuthentication=KeyVaultClientSecret**"을 설정할 수 있습니다. <br/><br/> 자세한 내용은 [JDBC 드라이버에서 Always Encrypted 사용](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요. |
| keyStoreLocation<br/><br/>String<br/><br/>null | **keyStoreAuthentication=JavaKeyStorePassword** 의 경우에는 **keyStoreLocation** 속성이 Always Encrypted 데이터와 함께 사용할 열 마스터 키가 저장되는 Java 키 저장소 파일로의 경로를 확인합니다. 이 경로에는 키 저장소 파일 이름이 포함되어야 합니다.<br/><br/>자세한 내용은 [JDBC 드라이버에서 Always Encrypted 사용](using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요. |
| keyStorePrincipalId<br/><br/>String<br/><br/>null | **keyStoreAuthentication=KeyVaultManagedIdentity** 를 설정하는 경우 **keyStorePrincipalId** 속성은 올바른 Azure Active Directory 애플리케이션 클라이언트 ID를 지정합니다.  <br/><br/>자세한 내용은 [JDBC 드라이버에서 Always Encrypted 사용](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요. |
| keyStoreSecret<br/><br/>String<br/><br/>null | **keyStoreAuthentication=JavaKeyStorePassword** 의 경우에는 **keyStoreSecret** 속성이 키 저장소와 키에 대해 사용할 암호를 확인합니다. Java 키 저장소를 사용하는 경우에는 키 저장소와 키 암호가 동일해야 합니다.<br/><br/>자세한 내용은 [JDBC 드라이버에서 Always Encrypted 사용](../../connect/jdbc/using-always-encrypted-with-the-jdbc-driver.md)을 참조하세요. |
| lastUpdateCount<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | "true" 값을 설정할 경우 서버에 전달된 SQL 문에서 마지막 업데이트 횟수만 반환되며, 이 값을 단일 SELECT, INSERT 또는 DELETE 문에서 사용하면 서버 트리거로 인한 추가 업데이트 횟수를 무시할 수 있습니다. 이 속성을 "false"로 설정하면 서버 트리거로 인해 반환된 업데이트 횟수를 포함하여 모든 업데이트 횟수가 반환됩니다.<br/><br/> **참고:**  이 속성은 [executeUpdate](../../connect/jdbc/reference/executeupdate-method-sqlserverstatement.md) 메서드와 함께 사용될 경우에만 적용됩니다. 다른 모든 execute 메서드는 모든 결과 및 업데이트 횟수를 반환합니다. 이 속성은 서버 트리거에서 반환하는 업데이트 횟수에만 영향을 미치고 트리거 실행 중 발생하는 오류 또는 결과 집합에는 영향을 미치지 않습니다. |
| lockTimeout<br/><br/>int<br/><br/>-1 | 데이터베이스에서 잠금 시간 초과가 보고될 때까지의 대기 시간(밀리초)입니다. 기본 동작은 무한정 대기하는 것입니다. 이 값을 지정하면 연결의 모든 문에 대해 기본값으로 사용됩니다. **Statement.setQueryTimeout()** 은 특정 문에 대한 제한 시간 설정에 사용할 수 있습니다. 대기 시간이 없음을 나타내는 0을 값으로 지정할 수도 있습니다. |
| loginTimeout<br/><br/>int<br/>[0..65535]<br/><br/>15 | 드라이버가 연결 실패 제한 시간까지 대기해야 하는 시간(초)입니다. 0 값을 지정하면 기본적으로 15초로 지정되는 시스템 제한 시간이 사용됩니다. 0이 아닌 값은 드라이버가 연결 실패 제한 시간까지 대기해야 하는 시간(초)입니다.<br/><br/> Virtual Network 이름을 **Server** 연결 속성에 지정하는 경우 시간 제한 값을 3분 이상으로 지정하여 장애 조치(failover) 연결이 성공하도록 충분한 시간을 허용해야 합니다. 자세한 내용은 [고가용성, 재해 복구를 위한 JDBC 드라이버 지원](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요. |
| msiClientId<br/><br/>String<br/><br/>null | **ActiveDirectoryMSI** 인증 모드로 연결 설정 시 **accessToken** 획득에 사용할 MSI(관리 ID)의 클라이언트 ID입니다.|
| multiSubnetFailover<br/><br/>부울<br/><br/>false | [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] 가용성 그룹 또는 [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)] 장애 조치(failover) 클러스터 인스턴스의 가용성 그룹 수신기에 연결할 때는 항상 **multiSubnetFailover=true** 를 지정합니다. **multiSubnetFailover=true** 는 현재 활성 상태인 서버를 더 빠르게 검색하고 연결할 수 있도록 [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]를 구성합니다. 가능한 값은 true 및 false입니다. 자세한 내용은 [고가용성, 재해 복구를 위한 ODBC 드라이버 지원](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요.<br/><br/> [getPropertyInfo](../../connect/jdbc/reference/getpropertyinfo-method-sqlserverdriver.md), [getMultiSubnetFailover](../../connect/jdbc/reference/getmultisubnetfailover-method-sqlserverdatasource.md) 및 [setMultiSubnetFailover](../../connect/jdbc/reference/setmultisubnetfailover-method-sqlserverdatasource.md)를 사용하여 **multiSubnetFailover** 연결 속성에 프로그래밍 방식으로 액세스할 수 있습니다.<br/><br/> **참고:**  SQL Server용 Microsoft JDBC Driver 6.0부터는 가용성 그룹 수신기 연결 시 **multiSubnetFailover** 를 "true"로 설정하지 않아도 됩니다. 새 속성인 **transparentNetworkIPResolution** 은 기본적으로 사용 설정되어 (현재의) 활성 서버 감지와 연결을 지원합니다. |
| packetSize<br/><br/>int<br/>[-1 &#124; 0 &#124; 512..32767]<br/><br/>8000 | SQL Server와의 통신에 사용되는 네트워크 패킷 크기로서 바이트 단위로 지정합니다. 값 -1은 서버의 기본 패킷 크기가 사용됨을 나타내고 값 0은 최대값인 32767이 사용됨을 나타냅니다. 이 속성을 허용 범위 이외의 값으로 설정하면 예외가 발생합니다.<br/><br/> **중요:**  암호화가 설정된 경우(encrypt=true)에는 packetSize 속성을 사용하지 않는 것이 좋습니다. 그렇지 않으면 드라이버에서 연결 오류가 발생할 수 있습니다. 자세한 내용은 [SQLServerDataSource](../../connect/jdbc/reference/sqlserverdatasource-class.md) 클래스의 [setPacketSize](../../connect/jdbc/reference/setpacketsize-method-sqlserverdatasource.md) 메서드를 참조하세요. |
| password<br/><br/>String<br/>[&lt;=128 char]<br/><br/>null | SQL 사용자 및 암호에 연결하는 경우의 데이터베이스 암호입니다.<br/>보안 주체 이름과 암호를 사용하는 Kerberos 연결의 경우 이 속성은 Kerberos 보안 주체 암호로 설정됩니다. |
| portNumber,<br/>포트<br/><br/>int<br/>[0..65535]<br/><br/>1433 | [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]에서 수신 중인 포트입니다. 연결 문자열에 포트 번호가 지정되어 있으면 SQLbrowser에 요청을 보내지 않습니다. 포트와 instanceName을 모두 지정한 경우 지정된 포트로 연결합니다. 그러나 **instanceName** 의 유효성을 검사하여 포트와 일치하지 않는 경우 오류가 throw됩니다.<br/><br/> **중요:** SQLbrowser를 사용하는 것보다 더 안전하므로 항상 포트 번호를 지정하는 것이 좋습니다. |
| queryTimeout<br/><br/>int<br/><br/>-1 | 쿼리에서의 시간 제한까지 대기하는 시간(초)입니다. 기본값은 -1로서 시간 제한이 없음을 뜻합니다. 이 항목이 0으로 설정되면 무기한 대기를 뜻합니다. |
| responseBuffering<br/><br/>String<br/>["full" &#124; "adaptive"]<br/><br/>adaptive | 이 속성이 "adaptive"로 설정되어 있으면 필요할 때 최소한의 데이터가 버퍼링됩니다. 기본 모드는 "adaptive"입니다.<br/><br/> 이 속성이 "full"로 설정되어 있으면 문이 실행될 때 전체 결과 집합을 서버에서 읽습니다.<br/><br/> **참고:** JDBC 드라이버를 버전 1.2에서 업그레이드하면 기본 버퍼링 동작은 "adaptive"가 됩니다. 애플리케이션에서 "responseBuffering" 속성을 설정하지 않은 경우 버전 1.2 기본 동작을 유지하고 싶으면 연결 속성을 사용하거나 [SQLServerStatement](../../connect/jdbc/reference/sqlserverstatement-class.md) 개체의 [setResponseBuffering](../../connect/jdbc/reference/setresponsebuffering-method-sqlserverstatement.md) 메서드를 사용하여 responseBufferring 속성을 "full"로 설정해야 합니다. |
| selectMethod<br/><br/>String<br/>["direct" &#124; "cursor"]<br/><br/>direct | 이 속성을 "cursor"로 설정하면 **TYPE_FORWARD_ONLY** 및 **CONCUR_READ_ONLY** 커서에 대한 연결에서 생성된 각 쿼리에 대해 데이터베이스 커서가 만들어집니다. 이 속성은 대개 애플리케이션에서 클라이언트 메모리에 완전히 집어넣을 수 없는 큰 결과 집합을 생성하는 경우에만 필요합니다. 이 속성을 "cursor"로 설정하면 클라이언트 메모리에 제한된 수의 결과 집합 행만 유지됩니다. <br/><br/>기본 동작은 클라이언트 메모리에 모든 결과 집합 행이 유지되는 것입니다. 이 동작은 애플리케이션에서 모든 행을 처리하는 경우에 성능 면에서 가장 효과적입니다. |
| sendStringParameters...<br/>AsUnicode<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *sendStringParametersAsUnicode*<br/><br/>**sendStringParametersAsUnicode** 속성을 "true"로 설정하면 문자열 매개 변수가 유니코드 형식으로 서버에 전송됩니다.<br/><br/> **sendStringParametersAsUnicode** 속성을 "false"로 설정하면 문자열 매개 변수가 유니코드가 아닌 ASCII/MBCS 등의 형식으로 서버에 전송됩니다.<br/><br/> **sendStringParametersAsUnicode** 속성의 기본값은 "true"입니다.<br/><br/> **참고:** **sendStringParametersAsUnicode** 속성은 매개 변수 값을 **CHAR**, **VARCHAR** 또는 **LONGVARCHAR** JDBC 형식으로 보낼 때만 확인됩니다. [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) 및 [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) 클래스의 setNString, setNCharacterStream 및 setNClob 메서드와 같은 새 JDBC 4.0 국가별 문자 메서드는 항상 이 속성의 설정에 관계없이 매개 변수 값을 유니코드로 서버에 보냅니다.<br/><br/> **CHAR**, **VARCHAR** 및 **LONGVARCHAR** JDBC 데이터 형식을 사용할 때 성능을 최적화하려면 애플리케이션에서 **sendStringParametersAsUnicode** 속성을 "false"로 설정하고 [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) 및 [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md)클래스의 국가별 문자 메서드가 아닌 setString, setCharacterStream 및 setClob를 사용해야 합니다.<br/><br/> 애플리케이션에서 **sendStringParametersAsUnicode** 속성을 "false"로 설정하고 국가별 문자 메서드가 아닌 메서드를 사용하여 서버측 유니코드 데이터 형식(예: **nchar**, **nvarchar** 및 **ntext**)에 액세스하는 경우 데이터베이스 데이터 정렬에서 국가별 문자 메서드가 아닌 메서드가 전달하는 문자열 매개 변수의 문자를 지원하지 않으면 일부 데이터가 손실될 수 있습니다.<br/><br/> 애플리케이션에서는 **NCHAR**, **NVARCHAR** 및 **LONGNVARCHAR** JDBC 데이터 형식에 대해 [SQLServerPreparedStatement](../../connect/jdbc/reference/sqlserverpreparedstatement-class.md) 및 [SQLServerCallableStatement](../../connect/jdbc/reference/sqlservercallablestatement-class.md) 클래스의 setNString, setNCharacterStream, setNClob 국가별 문자 메서드를 사용해야 합니다. |
| sendTemporalDataTypesAsStringForBulkCopy<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | 이 연결 속성을 "false"로 설정하면 **DATE**, **DATETIME**, **DATIMETIME2**, **DATETIMEOFFSET**, **SMALLDATETIME** 및 **TIME** 데이터를 문자열로 전송하는 대신 해당 형식으로 전송합니다.<br/><br/>이 연결 속성을 "false"로 설정하면 드라이버는 각 시간 데이터 형식의 기본 문자열 리터럴 형식만 허용합니다. 예를 들면 다음과 같습니다.<br/><br/>DATE: YYYY-MM-DD<br/>DATETIME: YYYY-MM-DD hh:mm:ss[.nnn]<br/>DATETIME2: YYYY-MM-DD hh:mm:ss[.nnnnnnn]<br/>DATETIMEOFFSET: YYYY-MM-DD hh:mm:ss[.nnnnnnn] [{+/-}hh:mm]<br/>SMALLDATETIME:YYYY-MM-DD hh:mm:ss<br/>TIME: hh:mm:ss[.nnnnnnn]<br/> |
| sendTimeAsDatetime<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | 이 속성은 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] JDBC 드라이버 3.0에서 추가되었습니다.<br/><br/> "true"면 java.sql.Time 값이 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]**datetime** 값으로서 서버에 보내집니다. <br/>"false"면 java.sql.Time 값이 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] **time** 값으로서 서버에 보내집니다.<br/><br/> 이 속성의 기본값은 현재 "true"이며, 이후 버전에서 변경될 수 있습니다.<br/><br/> [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]에서 java.sql.Time 값을 서버로 보내기 전에 구성하는 방식에 대한 자세한 내용은 [java.sql.Time 값을 서버에 보내는 방식 구성](../../connect/jdbc/configuring-how-java-sql-time-values-are-sent-to-the-server.md)을 참조하세요. |
| serverName,<br/>서버<br/><br/>String<br/><br/>null | [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]를 실행하는 컴퓨터입니다.<br/><br/> [!INCLUDE[ssHADR](../../includes/sshadr_md.md)] 가용성 그룹의 Virtual Network 이름을 지정할 수도 있습니다. 자세한 내용은 [고가용성, 재해 복구를 위한 JDBC 드라이버 지원](../../connect/jdbc/jdbc-driver-support-for-high-availability-disaster-recovery.md)을 참조하세요. |
| serverNameAsACE<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | SQL Server용 Microsoft JDBC Driver 6.0부터 이 속성을 "true"로 설정하면 드라이버가 유니코드 서버 이름을 ASCII 호환 인코딩(Punycode)으로 변환해서 연결해야 합니다. 이 설정이 false이면 드라이버는 사용자가 제공한 서버 이름을 사용하여 연결합니다.<br/><br/> 자세한 내용은 [JDBC 드라이버의 국가별 기능](../../connect/jdbc/international-features-of-the-jdbc-driver.md)을 참조하세요. |
| serverPreparedStatement...<br/>DiscardThreshold<br/><br/>정수<br/><br/>10 | *serverPreparedStatementDiscardThreshold*<br/><br/>SQL Server용 JDBC Driver 6.2부터 이 설정은 서버의 미처리 핸들을 정리하기 위한 호출 실행 전에 연결별로 처리되지 않을 수 있는 미처리 준비 문 삭제 작업(<code>sp_unprepare</code>)의 수를 제어합니다. <br/><br/> 설정이 &lt;= 1로 되어 있다면 준비된 문이 종료되자마자 준비 취소 작업이 곧바로 실행됩니다. 설정이 &gt;1로 되어 있다면 이러한 호출은 sp_unprepare 호출이 너무 잦아지는 오버헤드를 방지하기 위해 모두 함께 일괄 처리됩니다. |
| serverSpn<br/><br/>String<br/><br/>null | SQL Server용 Microsoft JDBC Driver 4.2부터는 이 선택적 속성을 사용하여 Java Kerberos 연결에 대한 SPN(서비스 사용자 이름)을 지정할 수 있습니다.  이는 **authenticationScheme** 과 함께 사용됩니다.<br/><br/> SPN을 지정하려면 “MSSQLSvc/fqdn:port@REALM” 형식이 될 수 있습니다. 여기서 fqdn은 정규화된 도메인 이름이고, port는 포트 번호이며, REALM은 대문자로 표시된 SQL Server의 Kerberos 영역입니다.<br/><br/> 참고: @REALM은 Kerberos 구성에 지정된 클라이언트의 기본 영역이 SQL Server의 Kerberos 영역과 동일한 경우 선택 사항입니다.<br/><br/> Java Kerberos에서 **serverSpn** 사용에 대한 자세한 내용은 [Kerberos 통합 인증을 사용하여 SQL Server에 연결](../../connect/jdbc/using-kerberos-integrated-authentication-to-connect-to-sql-server.md)을 참조하세요. |
| socketFactoryClass<br/><br/>String<br/><br/>null | 기본 소켓 팩터리 대신 사용할 사용자 지정 소켓 팩터리의 클래스 이름을 지정합니다. |
| socketTimeout<br/><br/>int<br/><br/>0 | 소켓 읽기 또는 허용의 시간 제한 동안 대기할 시간(밀리초)입니다. 기본값은 0으로서 시간 제한이 없음을 뜻합니다. |
| statementPooling...<br/>CacheSize<br/><br/>int<br/><br/>0 | *statementPoolingCacheSize*<br/><br/>SQL Server용 Microsoft JDBC Driver 6.4부터는 이 속성을 사용하여 드라이버 내의 준비 문 핸들 캐싱을 사용 설정할 수 있습니다. <br/><br/>이 속성은 문 풀링의 캐시 크기를 정의합니다. <br/><br/>이 속성은 "false"로 설정되어야 하는 **disableStatementPooling** 연결 속성과만 함께 사용할 수 있습니다. **disableStatementPooling** 을 "true"로 설정하거나 **statementPoolingCacheSize** 를 0으로 설정하면 준비된 문 핸들의 캐싱의 사용 설정이 해제됩니다.|
| sslProtocol<br/><br/>String<br/><br/>TLS | JDBC Driver 6.4 for SQL Server부터 이 속성을 사용하여 보안 연결 중에 고려할 TLS 프로토콜을 지정할 수 있습니다. <br/>가능한 값은 다음과 같습니다. **TLS**, **TLSv1**, **TLSv1.1** 및 **TLSv1.2** 입니다. <br/><br/>자세한 내용은 [SSLProtocol](https://github.com/Microsoft/mssql-jdbc/wiki/SSLProtocol)을 참조하세요. |
| transparentNetwork...<br/>IPResolution<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>true | *transparentNetworkIPResolution*<br/><br/>SQL Server용 Microsoft JDBC Driver 6.0부터는 이 속성이 (현재의) 활성 서버 감지와 연결을 더욱 신속하게 지원합니다. 가능한 값은 "true"와 "false"입니다. 여기서의 기본값은 "true"입니다.<br/><br/> SQL Server용 Microsoft JDBC Driver 6.0 이전에는 애플리케이션이 연결 문자열을 설정하여 "multiSubnetFailover=true"를 포함함으로써 AlwaysOn 가용성 그룹으로 연결되었음을 보여야 했습니다. **multiSubnetFailover** 연결 키워드를 "true"로 설정하지 않으면 AlwaysOn 가용성 그룹 연결 중 애플리케이션에 시간 제한이 적용될 수 있습니다. SQL Server용 Microsoft JDBC Driver 6.0부터는 애플리케이션이 multiSubnetFailover를 "true"로 설정하지 않아도 됩니다. <br/><br/>**참고:** transparentNetworkIPResolution=true의 경우에는 첫 연결 시도에서 500ms가 시간 제한으로 사용됩니다. 모든 후속 시도에서는 multiSubnetFailover 속성에서 사용되는 것과 동일한 시간 제한 논리가 사용됩니다. |
| trustManagerClass<br/><br/>String<br/><br/>null | 사용자 지정 <code>javax.net.ssl.TrustManager</code> 구현의 정규화 클래스 이름입니다. |
| trustManager...<br/>ConstructorArg<br/><br/>String<br/><br/>null | *trustManagerConstructorArg*<br/><br/>TrustManager의 생성자에 전달할 선택적 인수입니다. trustManagerClass가 지정되고 암호화된 연결이 요청되면 기본 시스템 JVM 키 저장소 기반 TrustManager가 아닌 사용자 지정 TrustManager가 사용됩니다. |
| trustServerCertificate<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]에서 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] TLS/SSL 인증서의 유효성을 검사하지 않도록 지정하려면 “true”로 설정합니다.<br/><br/> “true”이면, 통신 계층이 TLS를 사용하여 암호화된 경우 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] TLS/SSL 인증서가 자동으로 신뢰됩니다.<br/><br/> “false”이면, [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]에서 서버 TLS/SSL 인증서의 유효성을 검사합니다. 서버 인증서의 유효성 검사에 실패하면, 드라이버에서 오류가 발생하고 연결이 종료됩니다. 기본값은 "false"입니다. TLS/SSL 연결이 성공하려면 **serverName** 에 전달된 값이 서버 인증서의 주체 대체 이름에 있는 CN(일반 이름) 또는 DNS 이름과 정확히 일치해야 합니다. 자세한 내용은 [암호화 지원 이해](../../connect/jdbc/understanding-ssl-support.md)를 참조하세요.<br/><br/> **참고:** 이 속성은 **encrypt**/**authentication** 속성과 함께 사용됩니다. 이 속성은 TLS 암호화가 연결에 사용되는 경우에만 서버 TLS/SSL 인증서의 유효성 검사에 영향을 줍니다. |
| trustStore<br/><br/>String<br/><br/>null | 인증서 trustStore 파일에 대한 경로(파일 이름 포함)입니다. trustStore 파일에는 클라이언트에서 신뢰하는 인증서 목록이 포함되어 있습니다.<br/><br/> 이 속성이 지정되지 않았거나 null로 설정된 경우 드라이버에서는 트러스트 관리자 팩터리의 조회 규칙에 따라 사용할 인증서 저장소를 결정합니다.<br/><br/> **기본 SunX509 TrustManagerFactory는 다음 검색 순서에 따라 기본 트러스트 자료를 찾으려고 합니다.**<br/><br/> "javax.net.ssl.trustStore" JVM(Java Virtual Machine) 시스템 속성에 지정된 파일<br/><br/> "&lt;java-home&gt;/lib/security/jssecacerts" 파일.<br/><br/> "&lt;java-home&gt;/lib/security/cacerts" 파일.<br/><br/> <br/><br/> 자세한 내용은 Sun Microsystems 웹 사이트에서 SUNX509 TrustManager 인터페이스 설명서를 참조하십시오.<br/><br/> **참고:** 이 속성은 TLS 암호화가 연결에 사용되고 **trustServerCertificate** 속성의 설정이 “false”인 경우에만 인증서 trustStore 조회에 영향을 줍니다. |
| trustStorePassword<br/><br/>String<br/><br/>null | trustStore 데이터의 무결성을 검사하는 데 사용되는 암호입니다.<br/><br/> trustStore 속성은 설정되어 있지만 trustStorePassword 속성이 설정되어 있지 않는 경우 trustStore의 무결성을 검사하지 않습니다.<br/><br/> trustStore 속성과 trustStorePassword 속성이 모두 지정되어 있지 않는 경우 드라이버에서 JVM 시스템 속성 "javax.net.ssl.trustStore" 및 "javax.net.ssl.trustStorePassword"를 사용합니다. "javax.net.ssl.trustStorePassword" 시스템 속성이 지정되어 있지 않는 경우 trustStore의 무결성을 검사하지 않습니다.<br/><br/> trustStore 속성은 설정되어 있지 않지만 trustStorePassword 속성이 설정되어 있는 경우 JDBC 드라이버에서는 "javax.net.ssl.trustStore"에 지정된 파일을 트러스트 저장소로 사용하여 지정된 trustStorePassword로 트러스트 저장소의 무결성을 검사합니다. 클라이언트 애플리케이션이 JVM 시스템 속성에 암호를 저장하지 않는 경우 이 방법이 필요할 수 있습니다.<br/><br/> **참고:**  trustStorePassword 속성은 TLS 암호화가 연결에 사용되고 **trustServerCertificate** 속성의 설정이 “false”인 경우에만 인증서 trustStore 조회에 영향을 줍니다. |
| trustStoreType<br/><br/>String<br/><br/>JKS | FIPS 모드에 사용할 신뢰 저장소 유형을 지정하려면 이 속성을 설정합니다. <br/><br/>가능한 값은 **PKCS12** 이거나 FIPS 공급자에 의해 정의된 형식 중 하나입니다. |
| useBulkCopyFor...<br/>BatchInsert<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | _useBulkCopyForBatchInsert_<br/><br/> SQL Server용 Microsoft JDBC Driver 7.0부터는 성능 향상을 위해 `java.sql.PreparedStatement`를 사용하여 일괄 처리 삽입 작업을 수행할 때 대량 복사 API를 사용하도록 이 연결 속성이 사용 설정될 수 있습니다. <br/><br/>이 기능은 대상 서버가 **Azure Data Warehouse** 유형일 경우에만 작동합니다. 기본적으로는 사용하지 않도록 설정되어 있으며, 이 속성을 "true"로 설정하면 기능이 사용 설정됩니다. <br/></br> **중요 정보:** 이 기능은 완전히 매개 변수가 있는 INSERT 쿼리만 지원합니다. INSERT 쿼리가 다른 SQL 쿼리와 결합되거나 값에 데이터를 포함하면 실행이 기본적인 일괄 처리 삽입 작업으로 대체됩니다. <br/><br/> 이 속성의 사용 방법에 대한 자세한 내용은 [일괄 처리 삽입 작업에 대량 복사 API 사용](use-bulk-copy-api-batch-insert-operation.md)을 참조하세요.|
| useFmtOnly<br /><br />boolean<br />["true" &#124; "false"]<br /><br />false | SQL Server용 Microsoft JDBC Driver는 버전 7.4부터 **useFmtOnly** 연결 속성을 지정하여 서버의 매개 변수 메타데이터를 쿼리할 대안을 제공합니다. 이 속성이 "true"로 설정되면 매개 변수 메타데이터를 쿼리할 때 드라이버에서 `SET FMTONLY` 논리를 사용하도록 지정됩니다. 이 기능은 기본적으로 사용 설정되어 있지 않으며, `SET FMTONLY`에 사용 중단 표시가 되어 있으므로 이 속성을 사용하는 것 또한 권장하지 않습니다. **useFmtOnly** 는 [`sp_describe_undeclared_parameters`](../../relational-databases/system-stored-procedures/sp-describe-undeclared-parameters-transact-sql.md)의 제한 사항과 알려진 문제를 해결하는 용도로만 사용할 수 있습니다.<br/><br/> 이 기능은 현재 단일 `SELECT/INSERT/UPDATE/DELETE` 쿼리만 지원합니다. 지원되지 않거나 여러 개인 쿼리로 이 기능을 사용하려 하면 드라이버가 쿼리의 구문 분석을 시도하게 되지만, 대부분의 경우에는 예외가 발생할 수 있습니다.<br/><br/> 자세한 내용은 [Retrieving ParameterMetaData via useFmtOnly](../../connect/jdbc/using-usefmtonly.md)를 참조하세요. |
| userName,<br/>사용자<br/><br/>String<br/>[&lt;=128 char]<br/><br/>null | SQL 사용자 및 암호에 연결하는 경우의 데이터베이스 사용자입니다.<br/><br/>보안 주체 이름과 암호를 사용하는 Kerberos 연결의 경우 이 속성은 Kerberos 보안 주체 이름으로 설정됩니다. |
| workstationID<br/><br/>String<br/>[&lt;=128 char]<br/><br/>&lt;빈 문자열&gt; | 워크스테이션 ID로, 다양한 [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] 프로파일링 및 로깅 도구에서 특정 워크스테이션을 식별하는 데 사용됩니다. <br/><br/>지정하지 않으면 &lt;빈 문자열&gt;이 사용됩니다. |
| xopenStates<br/><br/>boolean<br/>["true" &#124; "false"]<br/><br/>false | "true"로 설정하면 드라이버에서 예외 발생 시 XOPEN 규격 상태 코드를 반환합니다. <br/><br/>기본값은 SQL 99 상태 코드를 반환하는 것입니다. |
| &nbsp; | &nbsp; |

> [!NOTE]  
> [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]는 ANSI_DEFAULTS 및 IMPLICIT_TRANSACTIONS를 제외하고 연결 속성에 대해 서버 기본값을 사용합니다. [!INCLUDE[jdbcNoVersion](../../includes/jdbcnoversion_md.md)]에서는 자동으로 ANSI_DEFAULTS를 ON으로 설정하고 IMPLICIT_TRANSACTIONS를 OFF로 설정합니다.

> [!Important]
> 인증 설정이 ActiveDirectoryPassword로 되어 있는 경우에는 [azure-activedirectory-library-for-java](https://github.com/AzureAD/azure-activedirectory-library-for-java)라는 라이브러리가 클래스 경로에 포함되어야 합니다. 이는 [Maven 리포지토리](https://mvnrepository.com/artifact/com.microsoft.azure/adal4j)에서 찾을 수 있습니다. 가장 간단한 라이브러리 및 해당 종속성 다운로드 방법은 다음과 같이 Maven을 사용하는 것입니다.
> 1. 먼저 시스템에 Maven을 설치합니다.
> 2. 드라이버의 [GitHub 페이지](https://github.com/Microsoft/mssql-jdbc)로 이동합니다.
> 3. pom.xml 파일을 다운로드합니다.
> 4. `mvn dependency:copy-dependencies`라는 Maven 명령을 실행하여 라이브러리와 그 종속성을 다운로드합니다.

## <a name="see-also"></a>참고 항목

[JDBC 드라이버로 SQL Server에 연결](../../connect/jdbc/connecting-to-sql-server-with-the-jdbc-driver.md)  
[FIPS 모드](../../connect/jdbc/fips-mode.md)