---
title: 메모리 액세스에 최적화된 테이블에 대한 내구성 | Microsoft 문서
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: d304c94d-3ab4-47b0-905d-3c8c2aba9db6
author: CarlRabeler
ms.author: carlrab
manager: craigg
ms.openlocfilehash: 3a35d5cdb9db4c56579a4229b2d08014a99da542
ms.sourcegitcommit: 3026c22b7fba19059a769ea5f367c4f51efaf286
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/15/2019
ms.locfileid: "63072765"
---
# <a name="durability-for-memory-optimized-tables"></a>메모리 액세스에 최적화된 테이블에 대한 내구성
  [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]는 메모리 최적화 테이블에 대한 완전한 내구성을 제공합니다. 메모리 최적화 테이블을 변경한 트랜잭션을 커밋할 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]를 사용하면 (디스크 기반 테이블과 마찬가지로) 기본 스토리지를 사용할 수 있는 경우 변경 내용이 영구적이 됩니다(데이터베이스 다시 시작 유지). 내구성의 두 가지 주요 구성 요소는 트랜잭션 로깅 및 디스크상 스토리지에 데이터 변경 내용 저장입니다.  
  
## <a name="transaction-log"></a>트랜잭션 로그  
 디스크 기반 테이블 또는 메모리 최적화 내구성이 있는 테이블에 대한 모든 변경은 하나 이상의 트랜잭션 로그 레코드에 캡처됩니다. 트랜잭션이 커밋될 때 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] 는 트랜잭션이 커밋된 애플리케이션 또는 사용자 세션과 통신하기 전에 디스크에 트랜잭션과 관련된 로그 레코드를 씁니다. 이렇게 하면 트랜잭션에 의한 변경 사항이 내구성을 가집니다. 메모리 최적화 테이블에 대한 트랜잭션 로그는 디스크 기반 테이블에서 사용되는 동일한 로그 스트림과 완전히 통합되어 있습니다. 이러한 통합에 따라 기존 트랜잭션 로그 백업, 복구 및 복원 작업이 추가 단계를 필요로 하지 않고 계속 수행될 수 있습니다. 그러나 [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]가 작업의 트랜잭션 처리량을 크게 증가시킬 수 있으므로 트랜잭션 로그 저장소가 증가한 IO 요구 사항을 처리할 수 있도록 적절하게 구성되어 있는지 확인해야 합니다.  
  
## <a name="data-and-delta-files"></a>데이터 및 델타 파일  
 메모리 최적화 테이블의 데이터는 하나 이상의 메모리 내 인덱스를 통해 연결된 자유 형식 데이터 행으로 메모리에 저장됩니다. 디스크 기반 테이블에 사용되는 페이지 구조와 같이 데이터 행에 대한 페이지 구조는 없습니다. 응용 프로그램이 트랜잭션을 커밋할 준비가 되면 [!INCLUDE[hek_2](../../../includes/hek-2-md.md)]는 트랜잭션에 대한 로그 레코드를 생성합니다. 메모리 최적화 테이블의 지속성은 백그라운드 스레드를 사용하여 데이터 집합 및 델타 파일로 수행됩니다. 데이터 및 델타 파일은 (FILESTREAM 데이터에 사용되는 동일한 메커니즘을 사용하는) 하나 이상의 컨테이너에 있습니다. 이러한 컨테이너는 메모리 최적화 파일 그룹이라는 파일 그룹의 새 형식에 매핑됩니다.  
  
 데이터는 이 파일에 기록될 때 회전 미디어의 디스크 대기 시간을 최소화하는 엄격한 순차적 방식으로 기록됩니다. 서로 다른 디스크의 여러 컨테이너를 사용하여 I/O 작업을 분산할 수 있습니다. 서로 다른 디스크의 여러 컨테이너에 있는 데이터 및 델타 파일은 디스크의 데이터 및 델타 파일에서 메모리로 데이터를 읽을 때 복구 성능을 향상시킵니다.  
  
 응용 프로그램은 데이터 및 델타 파일에 직접 액세스하지 않습니다. 모든 데이터 읽기 및 쓰기에서는 메모리 내 데이터를 사용합니다.  
  
### <a name="the-data-file"></a>데이터 파일  
 데이터 파일에는 여러 트랜잭션에서 삽입 또는 업데이트 작업 중에 삽입된 하나 이상의 메모리 최적화 테이블에서 가져온 행이 포함되어 있습니다. 예를 들어, 메모리 최적화 테이블 T1에서 한 행을 가져오고 메모리 최적화 테이블 T2에서 다음 행을 가져올 수 있습니다. 트랜잭션 로그의 트랜잭션 순서로 데이터 파일에 행을 추가하여 데이터 액세스를 순차적으로 지정합니다. 이렇게 하면 임의 I/O와 비교할 때 상당히 나은 I/O 처리량이 가능합니다. 각 데이터 파일의 크기는 16GB보다 메모리가 더 큰 컴퓨터의 경우 약 128MB, 16GB보다 메모리가 더 작거나 같은 컴퓨터의 경우 약 16MB입니다. 데이터 파일이 꽉 차면 새 트랜잭션에서 삽입되는 행은 다른 데이터 파일에 저장됩니다. 시간이 지날수록 메모리 최적화 영구 테이블의 행은 많은 데이터 파일 중 하나에 저장되고 결합되지 않았지만 연속하는 트랜잭션 범위에서 가져온 행이 각 데이터 파일에 포함됩니다. 예를 들어, 트랜잭션 커밋 타임스탬프 범위가 (100, 200)인 데이터 파일에는 커밋 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 의해 삽입된 모든 행이 포함됩니다. 커밋 타임스탬프는 커밋 준비가 되면 트랜잭션에 할당되는 단순하게 증가하는 숫자입니다. 각 트랜잭션에는 고유한 커밋 타임스탬프가 있습니다.  
  
 행을 삭제하거나 업데이트해도 해당 행은 데이터 파일에서 제거되거나 변경되지 않지만 삭제된 행은 다른 파일 형식인 델타 파일로 추적됩니다. 업데이트 작업은 각 행에 대한 삭제 및 삽입 작업의 튜플로 처리됩니다. 따라서 데이터 파일에서 임의의 IO가 제거됩니다.  
  
### <a name="the-delta-file"></a>델타 파일  
 각 데이터 파일은 트랜잭션 범위가 동일하고 해당 트랜잭션 범위에서 트랜잭션에 의해 삽입된 삭제된 행을 추적하는 델타 파일과 쌍을 이룹니다. 이 데이터 및 델타 파일은 CFP(검사점 파일 쌍)이라고 하며, 병합 작업을 위한 단위는 물론 할당 및 할당 취소 작업의 단위이기도 합니다. 예를 들어, 트랜잭션 범위 (100, 200)에 해당하는 델타 파일은 범위 (100, 200)의 트랜잭션에 의해 삽입된 삭제된 행을 저장합니다. 데이터 파일과 마찬가지로 델타 파일은 순차적으로 액세스됩니다.  
  
 행이 삭제되면 해당 행은 데이터 파일에서 제거되지 않지만 이 데이터 행이 삽입된 트랜잭션 범위에 연결된 델타 파일에 행에 대한 참조가 추가됩니다. 삭제할 행이 데이터 파일에 이미 있기 때문에 델타 파일은 참조 정보 `{inserting_tx_id, row_id, deleting_tx_id }` 만 원래 삭제 또는 업데이트 작업의 트랜잭션 로그 순서에 따라 저장합니다.  
  
## <a name="populating-data-and-delta-files"></a>데이터 및 델타 파일 채우기  
 데이터 및 델타 파일은 오프 라인 검사점이라는 백그라운드 스레드에 의해 채워집니다. 이 스레드는 메모리 최적화 테이블에서 커밋된 트랜잭션에 의해 생성되는 트랜잭션 로그 레코드를 읽고 삽입된 행과 삭제된 행에 대한 정보를 해당 데이터 및 델타 파일에 추가합니다. 검사점이 완료되면 데이터/인덱스 페이지가 임의 I/O로 플러시되는 디스크 기반 테이블과 달리 메모리 최적화 테이블은 계속해서 백그라운드 작업으로 지속됩니다. 트랜잭션을 삭제하거나 이전 트랜잭션에 의해 삽입된 모든 행을 업데이트하기 때문에 여러 개의 델타 파일이 액세스됩니다. 삭제 정보는 항상 델타 파일의 끝에 추가됩니다. 예를 들어, 커밋 타임스탬프가 600인 트랜잭션은 한 행을 삽입하고 아래 그림처럼 150, 250 및 450의 커밋 타임스탬프를 갖는 트랜잭션에 의해 삽입된 행을 삭제합니다. 모두 4번의 파일 I/O 작업(삭제된 행에 3번, 새로 삽입된 행에 1번)이 해당 델타 및 데이터 파일에 대한 추가 전용 작업입니다.  
  
 ![메모리 최적화 테이블의 로그 레코드를 읽습니다.](../../database-engine/media/read-logs-hekaton.gif "Read log records for memory-optimized tables.")  
  
## <a name="accessing-data-and-delta-files"></a>데이터 및 델타 파일 액세스  
 데이터 및 델타 파일 쌍은 다음이 발생할 때 액세스됩니다.  
  
 오프라인 검사점 스레드  
 이 스레드는 메모리 최적화 데이터 행을 해당 데이터 및 델타 파일 쌍에 삽입하고 삭제합니다.  
  
 병합 작업  
 작업은 하나 이상의 데이터 및 델타 파일 쌍을 병합하고 새로운 데이터 및 델타 파일 쌍을 만듭니다.  
  
 충돌 복구 동안  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]을 다시 시작하거나 데이터베이스가 다시 온라인이 되면 데이터 및 델타 파일 쌍을 사용하여 메모리 최적화 데이터가 채워집니다. 델타 파일은 해당 데이터 파일에서 행을 읽을 때 삭제된 행에 대한 필터의 역할을 합니다. 각 데이터 및 델타 파일 쌍은 서로 독립적이기 때문에 이러한 파일은 메모리에 데이터를 채우는 데 걸리는 시간을 줄이기 위해 병렬로 로드됩니다. 데이터가 메모리로 로드되면 메모리 내 OLTP 엔진은 메모리 최적화 데이터가 완전하도록 검사점 파일에 아직 포함되지 않은 활성 트랜잭션 로그 레코드를 적용합니다.  
  
 복원 작업 동안  
 메모리 내 OLTP 검사점 파일이 데이터베이스 백업에서 만들어진 다음 하나 이상의 트랜잭션 로그 백업이 적용됩니다. 충돌 복구와 마찬가지로 메모리 내 OLTP 엔진은 데이터를 병렬로 메모리로 로드하여 복구 시간에 미치는 영향을 최소화합니다.  
  
## <a name="merging-data-and-delta-files"></a>데이터 및 델타 파일 병합  
 메모리 액세스에 최적화된 테이블에 대한 데이터는 하나 이상의 데이터 및 델타 파일 쌍(검사점 파일 쌍 또는 CFP 라고도 함)에 저장됩니다. 데이터 파일에는 삽입된 행이 저장되고 델타 파일은 삭제된 행을 참조합니다. OLTP 작업을 실행하는 동안 DML 작업에서는 행을 업데이트, 삽입 및 삭제하고, 새 행을 유지하기 위한 새 CFP가 만들어지고, 삭제된 행에 대한 참조가 델타 파일에 추가됩니다.  
  
 모든 이전에 닫은 CFP와 현재 활성화된 CFP의 메타데이터가 저장소 배열이라는 내부 배열 구조에 저장됩니다. 유한 크기(8,192개 항목)의 CFP 배열입니다. 저장소 배열의 항목은 트랜잭션 범위순으로 정렬됩니다. 스토리지 배열의 CFP는 비상 로그와 함께 메모리 최적화 테이블로 데이터베이스를 복구하는 데 필요한 모든 디스크 상태를 나타냅니다.  
  
 시간이 지날수록 DML 작업으로 CFP 수가 늘어나 저장소 배열이 용량에 도달하여 다음과 같은 문제가 발생합니다.  
  
-   삭제된 행.  삭제된 행은 데이터 파일에서는 유지되지만 해당 델타 파일에서는 삭제된 것으로 표시됩니다. 이러한 행은 더 이상 필요하지 않으므로 저장소에서 제거됩니다. 삭제된 행은 CPF에서 제거되지 않은 경우 불필요한 공간을 차지하여 복구 시간이 느려집니다.  
  
-   스토리지 배열이 꽉 찼습니다. 저장소 배열에 8000개 항목이 할당된 경우(수동 병합을 완료하거나 수동 병합을 수행할 수 있도록 배열의 192개 항목이 기존 병합에 예약된 경우) 메모리 최적화 영구 테이블에서 새로운 DML 트랜잭션을 실행할 수 없습니다. 검사점 및 병합 작업에서만 나머지 항목을 사용할 수 있습니다. 이렇게 하면 DML 트랜잭션은 배열을 채우지 않고 배열의 일부 항목이 기존 파일을 병합하고 배열의 공간 확보를 위해 예약됩니다.  
  
-   스토리지 배열 조작 오버헤드입니다. 내부 프로세스는 저장소 배열에서 작업(예: 삭제된 행에 대한 정보를 추가할 델타 파일 찾기)을 검색합니다. 이러한 작업은 항목의 수에 따라 증가합니다.  
  
 이러한 비효율성을 방지하려면 아래에 설명된 병합 정책에 따라 오래된 닫힌 CFP를 병합하여 더 적은 수의 CFP로 동일한 데이터 집합을 나타내도록 저장소 배열을 압축합니다.  
  
 데이터베이스에 있는 모든 영구 테이블의 총 메모리 내 크기는 250GB를 초과할 수 없습니다. 최대 250GB의 메모리를 사용하는 영구 테이블은 작업을 삽입, 삭제 및 업데이트할 것을 고려할 때 평균 500GB의 저장 공간이 필요합니다. 메모리 최적화 파일 그룹의 데이터 및 델타 파일 4000쌍은 500GB의 저장 공간을 지원해야 합니다.  
  
 데이터베이스 작업의 단기 급증으로 검사점 및 병합 작업이 지연될 수 있으며, 이로 인해 필요한 데이터 및 델타 파일 쌍의 수가 늘어납니다. 데이터베이스 작업의 단기 급증을 수용하기 위해 스토리지 시스템은 최대 1TB 저장소당 최대 데이터 및 델타 파일 8000쌍을 할당할 수 있습니다. 해당 한계에 도달하면 검사점 작업이 따라잡을 때까지 데이터베이스에서 허용되는 새 트랜잭션이 없습니다. 메모리에 있는 영구 테이블의 크기가 오랜 시간 동안 250GB를 초과하면 8000개 파일 쌍 제한에 도달하는 경우도 있습니다.  
  
 병합 작업에서는 내부적으로 정의된 병합 정책에 따라 하나 이상의 인접한 닫힌 CFP(병합 원본)를 입력으로 사용하여 병합 대상이라는 단일 결과 CFP를 생성합니다. 원본 CFP의 각 델타 파일에 있는 항목은 해당 데이터 파일에서 행을 필터링하여 필요 없는 데이터 행을 제거하는 데 사용됩니다. 원본 CFP의 나머지 행은 하나의 대상 CFP로 통합됩니다. 병합이 완료되면 원본 CFP(병합 원본)가 결과 병합 대상 CFP로 대체됩니다. 병합 원본 CFP는 전환 단계를 완료한 후 스토리지에서 제거됩니다.  
  
 아래 예제에서 메모리 최적화 테이블 파일 그룹에는 이전 트랜잭션의 데이터를 포함하는 타임스탬프 500에 4개의 데이터와 델타 파일 쌍이 있습니다. 예를 들어, 첫 번째 데이터 파일의 행은 타임스탬프가 100보다 크고 200보다 작거나 같은 트랜잭션에 해당하며 (100, 200]으로 표시됩니다. 두 번째 및 세 번째 데이터 파일은 삭제된 것으로 표시된 행이 채워진 비율이 50% 미만으로 표시됩니다. 병합 작업에서는 이 두 CFP를 결합하고 타임스탬프가 200보다 크고 400보다 작거나 같은(이 두 CFP의 결합 범위) 트랜잭션을 포함하는 새 CFP를 만듭니다. 범위가 CFP (500, 600]인 다른 CFP가 표시되고 트랜잭션 범위 (200, 400]에 대한 비어 있지 않은 델타 파일은 원본 CFP에서 여러 행 삭제와 같은 트랜잭션 활동과 병합 작업을 동시에 수행할 수 있음을 나타냅니다.  
  
 ![다이어그램에서는 메모리 액세스에 최적화된 테이블 파일 그룹을 보여 줍니다.](../../database-engine/media/storagediagram-hekaton.png "Diagram shows memory optimized table file group")  
  
 백그라운드 스레드는 병합 정책에 따라 모든 닫힌 CFP를 평가한 다음 조건에 맞는 CFP에 대한 하나 이상의 병합 요청을 시작합니다. 이러한 병합 요청은 오프라인 검사점 스레드에서 처리됩니다. 병합 정책 평가는 주기적으로 수행되며 검사점을 닫을 때에도 수행됩니다.  
  
### <a name="includesssql14includessssql14-mdmd-merge-policy"></a>[!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] 병합 정책  
 [!INCLUDE[ssSQL14](../../../includes/sssql14-md.md)] 에서는 다음과 같은 병합 정책을 구현합니다.  
  
-   두 개 이상의 연속하는 CFP를 통합할 수 있는 경우 삭제된 행을 고려한 후 이상적인 크기의 CFP 하나에 결과 행을 모두 넣을 수 있도록 병합을 예약합니다. CFP의 이상적인 크기는 다음과 같이 결정됩니다.  
  
    -   컴퓨터에 16GB 이하의 메모리가 있는 경우 데이터 파일은 16MB이고 델타 파일은 1MB입니다.  
  
    -   컴퓨터에 16GB를 초과하는 메모리가 있는 경우 데이터 파일은 128MB이고 델타 파일은 16MB입니다.  
  
-   데이터 파일이 256MB를 초과하고 행이 절반 넘게 삭제된 경우 단일 CFP가 자체적으로 병합될 수 있습니다. 예를 들어 단일 트랜잭션 또는 여러 동시 트랜잭션이 많은 양의 데이터를 삽입하거나 업데이트하는 경우 트랜잭션이 여러 CFP에 걸쳐 있을 수 없기 때문에 데이터 파일이 이상적인 크기를 초과하게 되면 데이터 파일이 128MB보다 커질 수 있습니다.  
  
 다음은 병합 정책에 따라 병합될 CFP를 보여 주는 몇 가지 예입니다.  
  
|인접한 CFP 원본 파일 (채워진 비율)|병합 선택|  
|-------------------------------------------|---------------------|  
|CFP0 (30%), CFP1 (50%), CFP2 (50%), CFP3 (90%)|(CFP0, CFP1)<br /><br /> CFP2는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.|  
|CFP0 (30%), CFP1 (20%), CFP2 (50%), CFP3 (10%)|(CFP0, CFP1, CFP2) 파일은 왼쪽부터 선택됩니다.<br /><br /> CTP3는 결과 데이터 파일을 이성적인 크기의 100%를 초과하게 만들므로 선택되지 않습니다.|  
|CFP0 (80%), CFP1 (30%), CFP2 (10%), CFP3 (40%)|(CFP1, CFP2, CFP3). 파일은 왼쪽부터 선택됩니다.<br /><br /> CFP0는 CFP1과 결합할 경우 결과 데이터 파일이 이상적인 크기의 100%를 초과하게 되므로 건너뜁니다.|  
  
 사용 가능한 공간이 있는 CFP 중 일부는 병합할 수 없습니다. 예를 들어, 두 개의 인접한 CFP가 60% 채워진 경우 해당 CFP는 병합되지 않고 각 CFP의 스토리지 중 40%는 사용되지 않습니다. 최악의 경우 모든 CFP가 50% 채워진 경우 스토리지의 50%만 사용됩니다. CFP가 병합되지 않아 삭제된 행이 스토리지에 존재할 수 있지만 삭제된 행은 메모리 내 가비지 수집에 의해 메모리에서 이미 제거되었을 수 있습니다. 스토리지 관리와 메모리는 가비지 수집에 종속되지 않습니다. 활성 CFP가 차지하는 스토리지(일부 CFP는 업데이트되지 않음)는 메모리 내 영구 테이블 크기보다 최대 2배 더 클 수 있습니다.  
  
 필요한 경우 수동 병합을 수행할 수 있습니다 명시적으로 호출 하 여 [sys.sp_xtp_merge_checkpoint_files &#40;TRANSACT-SQL&#41;](/sql/relational-databases/system-stored-procedures/sys-sp-xtp-merge-checkpoint-files-transact-sql)합니다.  
  
### <a name="life-cycle-of-a-cfp"></a>CFP의 수명 주기  
 CPF 할당을 취소하려면 여러 상태를 전환해야 합니다. 언제든지 CFP는 PRECREATED, UNDER CONSTRUCTION, ACTIVE, MERGE TARGET, MERGED SOURCE, REQUIRED FOR BACKUP/HA, IN TRANSITION TO TOMBSTONE 및 TOMBSTONE 단계 중 하나에 속합니다. 이러한 단계에 대한 자세한 내용은 [sys.dm_db_xtp_checkpoint_files&#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql)를 참조하세요.  
  
 다양한 상태의 CFP가 차지하는 저장소를 고려한 후 메모리 최적화 영구 테이블이 차지하는 전체 저장소는 메모리 내 해당 테이블 크기의 2배보다 훨씬 클 수 있습니다. DMV [sys.dm_db_xtp_checkpoint_files &#40;TRANSACT-SQL&#41; ](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-checkpoint-files-transact-sql) 모든 Cfp는 메모리 최적화 파일 그룹의 해당 단계를 나열 하려면 쿼리할 수 있습니다. MERGE SOURCE 상태의 CFP를 TOMBSTONE으로 전환하면 결국 가비지 수집에서 최대 5개의 검사점을 사용할 수 있으며, 데이터베이스가 전체 또는 대량 로그 복구 모델에 대해 구성된 경우 각 검사점 뒤에는 트랜잭션 로그 백업이 수행됩니다.  
  
 검사점 후에 강제 로그 백업을 수동으로 수행하여 가비지를 빠르게 수집할 수 있지만 그러면 5개의 빈 CFP(데이터 파일의 크기가 각각 128MB인 5개의 데이터/델타 파일 쌍)가 추가됩니다. 프로덕션 시나리오에서 백업 전략의 일부로 수행되는 자동 검사점 및 로그 백업에서는 수동 작업을 수행할 필요 없이 이러한 단계에서 CFP를 완벽하게 전환합니다. 가비지 수집 프로세스의 영향으로 메모리 최적화 테이블을 포함하는 데이터베이스에 메모리 내 크기에 비해 큰 스토리지가 존재할 수 있습니다. CFP가 메모리에 있는 메모리 최적화 영구 테이블 크기의 최대 4배인 경우도 드물지 않습니다.  
  
## <a name="see-also"></a>관련 항목  
 [메모리 액세스에 최적화된 개체의 저장소 만들기 및 관리](creating-and-managing-storage-for-memory-optimized-objects.md)  
  
  
